package utils;

import java.io.StringWriter;
import java.util.ArrayList;
import java.util.List;

import org.eclipse.rdf4j.model.Value;
import org.eclipse.rdf4j.query.BindingSet;
import org.eclipse.rdf4j.query.GraphQuery;
import org.eclipse.rdf4j.query.GraphQueryResult;
import org.eclipse.rdf4j.query.QueryResults;
import org.eclipse.rdf4j.query.TupleQuery;
import org.eclipse.rdf4j.query.TupleQueryResult;
import org.eclipse.rdf4j.repository.Repository;
import org.eclipse.rdf4j.repository.RepositoryConnection;
import org.eclipse.rdf4j.repository.RepositoryException;
import org.eclipse.rdf4j.rio.RDFFormat;
import org.eclipse.rdf4j.rio.RDFWriter;
import org.eclipse.rdf4j.rio.Rio;


import com.complexible.stardog.api.ConnectionConfiguration;
import com.complexible.stardog.rdf4j.StardogRepository;

/**
 * Simple interface to the Stardog repository.
 * This class allows a connection to be initialized,
 * and provides methods to run various queries
 * @author Bonnie MacKellar
 *
 */

//TODO - should use connection pooling, also check for thread safety
public class RepositoryMgr {
   private static Repository repo;
   private static RepositoryConnection conn;
   
/**
 * This creates the connection to the database
 * @param url URL for Stardog repository
 * @param dbName  the name of the database
 * @param login
 * @param password
 */
   public void init(String url, String dbName, String login, String password) {
	   System.out.println("Connecting to " + url);
	   try {
		repo = new StardogRepository(ConnectionConfiguration
		           .to(dbName)
		           .server(url)
		           .credentials(login, password));

		    repo.initialize();
		  
	} catch (RepositoryException e) {
		   if (repo != null)
			   repo.shutDown();
		e.printStackTrace();
		
	}
   }
   

   public void close() {
	   conn.close();
	   repo.shutDown();
   }
   
   /**
    * This returns a list of trial identifiers (NCTID's) for trials
    * that contain an intervention name that matches the parameter
    * uses the full trial representation
    * @param intName  name of an intervention
    * @return  JSON-LD formatted string
    */
   public String getTrialIdsByInterventionName(String intName) {
	   conn = repo.getConnection();
	   GraphQuery gQuery = conn.prepareGraphQuery("construct {?nct fct:hasNCT ?nctid}"
				+ "where {?nct fct:hasNCT ?nctid."
				+ "?nct fct:hasIntervention ?int."
				+ "?int fct:hasInterventionName \"" + intName + "\".}");

		GraphQueryResult results = gQuery.evaluate();
		String resultsStr = formatResults(results);
		conn.close();
		return resultsStr;
   }
   
   /**
    * This returns the conflict oriented representation of a clinical trial geared to whose 
    * nctid matches the value in the parameter
    * Currently, the returned clinical trial information consists of the nct id,
    * a list of interventions (name and type), and a list of eligibility criteria, text only
    * The UMLS concepts and criteria classifications generated in the UIMA pipeline
    * are not currently returned.
    * @param nctid
    * @return
    */
   public String getTrialByNctID(String nctid) {
	   conn = repo.getConnection();
	   GraphQuery gQuery = conn.prepareGraphQuery("construct where { ?t ct:hasNCT \"" + nctid + "\"."
				+ "?t ct:hasIntervention ?int."
				+ "?int ct:hasName ?intName."
				+ "?int ct:hasType ?intType."
				+ "?t ct:hasEligCrit ?crit. "
				+ "?crit ct:criteriaText ?text.}");
	   
	   GraphQueryResult results = gQuery.evaluate();
		String resultsStr = formatResults(results);
		conn.close();
		return resultsStr;
	   
   }
   
   /**
    * This returns the conflicts generated by the trial whose nctid matches the parameter value
    * For each conflict, it returns the conflict resource name, the nctid of the conflicting trial, 
    * the UMLS concept id, the phrase in the criterion and the phrase in the intervention that matched,
    * and the full text of the criterion.
    * @param nctid
    * @return
    */
   public String getConflictsByNctID(String nctid) {
	   conn = repo.getConnection();
	   GraphQuery gQuery = conn.prepareGraphQuery("construct where { ?trial ct:hasNCT \"" + nctid + "\"."
				+ "?trial ct:hasConflict ?conflict."
				+ "?conflict ct:hasConflictNCT ?nctid."
				+ "?conflict ct:hasConflictCui ?cui."
				+ "?conflict ct:hasIntCoveredText ?icov."
				+ "?conflict ct:hasCriteriaCoveredText ?ccov."
				+ "?conflict ct:hasCriterion ?crit.}");
			
	   
	   GraphQueryResult results = gQuery.evaluate();
		String resultsStr = formatResults(results);
		conn.close();
		return resultsStr;
	   
   }

   /**
    * This returns the general representation of a clinical trial geared to whose 
    * nctid matches the value in the parameter
    * The general representation is intended to contain the bulk of the information
    * from clinicaltrials.gov, such as sponsors, start and end date, phase, etc.
    * It is only a partial representation at present.  Eligibility criteria are returned
    * as in their original representation - a large text block.
    * @param nctid
    * @return
    */
   public String getFullTrialByNctID(String nctid) {
	   conn = repo.getConnection();
	/*   GraphQuery gQuery = conn.prepareGraphQuery("construct where {?t fct:hasNCT \"" + nctid + "\"."
               + "?t fct:hasConflictRep ?conflictRep."
               + "?t fct:hasReqHeader ?reqHeader."
               + " ?t fct:hasSecondaryId ?secondaryId."
               + " ?t fct:hasBriefTitle ?briefTitle."
               + "?t fct:hasOrgStudyId ?orgStudyId."
               + " ?t fct:hasOfficialTitle ?officialTitle."
               + " ?t fct:hasLeadSponsor ?leadSponsor."
               + " ?t fct:hasCollabSponsor ?collabSponsor."
               + "  ?t fct:hasBriefSummary ?briefSummary."
               + "  ?t fct:hasDetailedDescrip ?detailDescrip."
               + " ?t fct:hasOverallStatus ?overallStatus."
               + "?t fct:hasOverallContactName ?overallConactName."
               + "?t fct:hasOverallContactPhone ?overallContactPhone."
                +  "?t fct:hasOverallContactEmail ?overallContactEmail."
               + " ?t fct:hasPhase ?phase."
               + "  ?t fct:hasStartDate ?startDate."
               + " ?t fct:hasCompletionDate ?completeDate."
               + " ?t fct:hasCondition ?cond."
               + " ?t fct:hasStudyType ?studyType."
               + " ?t fct:hasSamplingMethod ?sampMeth."
               + " ?t fct:hasCriteriaText ?criteria."
               + " ?t fct:hasHealthyVolunteers ?volun."
               + " ?t fct:hasGender ?gender."
               + " ?t fct:hasMinAge ?minAge."
               + " ?t fct:hasMaxAge ?maxAge. "
               + " ?t fct:hasIntervention ?inter."
               + " ?inter fct:hasInterventionName ?intername."
               + " ?inter fct:hasInterventionType ?intertype."
               + " ?inter fct:hasInterventionDescr ?interdesc."
               + " ?inter fct:hasInterventionArmGroupLabel ?armGrpLbl."
               + "?inter fct:hasInterventionOtherName ?oname."
               + "?t fct:hasLocation ?loc."
               + " ?loc fct:hasLocFacility ?fac."
                + "?loc fct:hasLocStatus ?stat."
                 + "?loc fct:hasLocCity ?loccity."
               + " ?loc fct:hasLocCountry ?locCountry."
               + " ?loc fct:hasLocState ?locstate."
                + "?loc fct:hasLocZip ?locZip."
                + "?loc fct:hasInvestigatorName ?invest."
                + " ?loc fct:hasLocContactName ?loccontactname."
                 + "?loc fct:hasLocContactPhone ?locContactphone."
                + " ?loc fct:hasLocContactEmail ?locContactemail."
                + "?loc fct:hasLocBackupContactName ?locBkupName."
                 + "?loc fct:hasLocBackupContactPhone ?locBkupPhone."
                + " ?loc fct:hasLocBackupContactEmail ?locBkupEmail."
               + "}");*/
	   String queryStr = "construct {" + getByNCTIDBody() + "} where {?t fct:hasNCT \"" + nctid + "\"." + getByNCTIDBody() + "}";
	   System.out.println(queryStr);
	   GraphQuery gQuery = conn.prepareGraphQuery(queryStr);	
	   
	   GraphQueryResult results = gQuery.evaluate();
		String resultsStr = formatResults(results);
		conn.close();
		return resultsStr;
	   
   }
   private String getByNCTIDBody() {
	   return "?t fct:hasConflictRep ?conflictRep."
               + "?t fct:hasReqHeader ?reqHeader."
               + " ?t fct:hasSecondaryId ?secondaryId."
               + "?t fct:hasBriefTitle ?briefTitle."
               + "?t fct:hasOrgStudyId ?orgStudyId."
               + " ?t fct:hasOfficialTitle ?officialTitle."
               + " ?t fct:hasLeadSponsor ?leadSponsor."
               + " ?t fct:hasCollabSponsor ?collabSponsor."
               + "  ?t fct:hasBriefSummary ?briefSummary."
               + "  ?t fct:hasDetailedDescrip ?detailDescrip."
               + " ?t fct:hasOverallStatus ?overallStatus."
               + "?t fct:hasOverallContactName ?overallConactName."
               + "?t fct:hasOverallContactPhone ?overallContactPhone."
               + " ?t fct:hasOverallContactEmail ?overallContactEmail."
               + " ?t fct:hasPhase ?phase."
                + " ?t fct:hasStartDate ?startDate."
                + "?t fct:hasCompletionDate ?completeDate."
               + " ?t fct:hasCondition ?cond."
               + " ?t fct:hasStudyType ?studyType."
               + " ?t fct:hasSamplingMethod ?sampMeth."
               + " ?t fct:hasCriteriaText ?criteria."
               + " ?t fct:hasHealthyVolunteers ?volun."
             + "?t fct:hasGender ?gender."
               + " ?t fct:hasMinAge ?minAge."
               + " ?t fct:hasMaxAge ?maxAge. "
               + " ?t fct:hasIntervention ?inter."
               + " ?inter fct:hasInterventionName ?intername."
               + " ?inter fct:hasInterventionType ?intertype."
               + " ?inter fct:hasInterventionDescr ?interdesc."
               + " ?inter fct:hasInterventionArmGroupLabel ?armGrpLbl."
              + " ?inter fct:hasInterventionOtherName ?oname."
              + " ?t fct:hasLocation ?loc."
               + " ?loc fct:hasLocFacility ?fac."
               + " ?loc fct:hasLocStatus ?stat."
                + " ?loc fct:hasLocCity ?loccity."
              + " ?loc fct:hasLocCountry ?locCountry."
               + " ?loc fct:hasLocState ?locstate."
               + " ?loc fct:hasLocZip ?locZip."
               + " ?loc fct:hasInvestigatorName ?invest."
                + " ?loc fct:hasLocContactName ?loccontactname."
                + " ?loc fct:hasLocContactPhone ?locContactphone."
                + " ?loc fct:hasLocContactEmail ?locContactemail."
               + " ?loc fct:hasLocBackupContactName ?locBkupName."
                + " ?loc fct:hasLocBackupContactPhone ?locBkupPhone."
                + " ?loc fct:hasLocBackupContactEmail ?locBkupEmail."
                 + "    ?t fct:hasPrimaryOutcome ?pout."       
               + "?t fct:hasSecondaryOutcome ?sout."
              + " ?pout fct:hasMeasure  ?pmeas."
              + " ?pout fct:hasTimeFrame ?ptf."
              + " ?pout fct:hasSafetyIssue ?psafe."
              + " ?pout fct:hasDescription ?pdescrip."
               + "     ?sout fct:hasMeasure  ?smeas."
              + " ?sout fct:hasTimeFrame ?stf."
              + " ?sout fct:hasSafetyIssue ?ssafe."
              + " ?sout fct:hasDescription ?sdescrip. ";
              
               
}
   
   public String getTrialIdsByCondition(String condition) {          
	    conn = repo.getConnection();          
	    
	    GraphQuery gQuery = conn.prepareGraphQuery("construct where {?t fct:hasCondition \"" + condition + "\"."
	                    + " ?t fct:hasNCT ?nct. }");          
	    GraphQueryResult results = gQuery.evaluate();
	   String resultsStr = formatResults(results);
	   conn.close();    return resultsStr;
	}
	
   /**
    * This returns the full representation of trials based on any number of search critieria
    * @param values - a list of namevalue pairs specifiying the search conditions
    * @return a JSON -LD string containing a list of clinical trial information
    */
   public String getFullTrialsByCriteria(ArrayList<NameValuePair> values){          
	   conn = repo.getConnection();          
	   QueryConditionList qcList = new QueryConditionList();
	  
	   qcList.replaceVarsWithValues(values);
		String q = qcList.makeRetrievalQuery();
		System.out.println(q);
		GraphQuery gQuery = conn.prepareGraphQuery(q);
	
	    
	   GraphQueryResult results = gQuery.evaluate();
	   String resultsStr = formatResults(results);
	   conn.close();    
	   return resultsStr;
	}

   /**
    * This returns the facet counts for the set of clinical trials retrieved based on the search criteria in values
    * @param facet - the facet to use for the counts. For example, if the facet is "intervention" then the number of
    * trials for each value of intervention will be returned
    * @param values - a list of namevalue pairs specifiying the search conditions
    * @return a JSON string containing a list of clinical trial information. Its format is 
    * {results[{facetVal: facet value,trialCount: trial count},....])
    * for example {results[{facetVal: filgrastin, trialCount: 11},...]}
    */
   public String getFacetForFullTrialRetrieve(String facet, ArrayList<NameValuePair> values){
	   conn = repo.getConnection();          
	   QueryConditionList qcList = new QueryConditionList();
	  
	   qcList.replaceVarsWithValues(values);
		String q = qcList.makeFacetQuery(facet);
		System.out.println(q);
		TupleQuery facetQuery = conn.prepareTupleQuery(q);
	
	    
		TupleQueryResult results = facetQuery.evaluate();


		List<String> bindingNames = results.getBindingNames();
		// first binding name should be the variable name used in the group by
		// clause
		// second should be the variable name for the count
		String facetVariable = bindingNames.get(0);
		String countVariable = bindingNames.get(1);
		System.err.println(facetVariable + " " + countVariable);
		
		Value facetValue;
		Value trialCount;
        ArrayList<String> elements = new ArrayList<String>();
		while (results.hasNext()) {
			BindingSet bindingSet = results.next();
			facetValue = bindingSet.getValue(facetVariable);
			trialCount = bindingSet.getValue(countVariable);
	          elements.add("{\"facetVal\":" + facetValue + ", \"trialCount\": "
					+ trialCount.stringValue() + "} ");
			System.err.println(facetValue.stringValue() + " " + trialCount.stringValue());
		
		}
		String resultStr = "{\"results\":[" + String.join(",", elements) + "]}";
		 
	   conn.close();    
	  return resultStr;
   }
   /**
    * This returns the full representation of trials for a specified condition 
    * that have hasOverallStatus as Recruiting.
    * @param condition
    * @return
    */
   // TODO - this is deprecated because above query is more general so can remove it
   public String getRecruitingFullTrialsByCondition(String condition) {              
	   conn = repo.getConnection();  
	   
	   GraphQuery gQuery = conn.prepareGraphQuery("construct where {?t fct:hasCondition \"" + condition + "\"."
			   + "?t fct:hasOverallStatus \"Recruiting\"."
			   + "?t fct:hasNCT ?nct."          
			   + "?t fct:hasConflictRep ?conflictRep."
			   + "?t fct:hasReqHeader ?reqHeader."
			   + "?t fct:hasSecondaryId ?secondaryId."
			   + "?t fct:hasBriefTitle ?briefTitle."
			   + "?t fct:hasOrgStudyId ?orgStudyId."
			   + "?t fct:hasOfficialTitle ?officialTitle."
			   + "?t fct:hasLeadSponsor ?leadSponsor."
			   + "?t fct:hasCollabSponsor ?collabSponsor."
			   + "?t fct:hasBriefSummary ?briefSummary."
			   + "?t fct:hasDetailedDescrip ?detailDescrip."
			   + "?t fct:hasOverallStatus ?overallStatus."
			   + "?t fct:hasOverallContactName ?overallConactName."
               + "?t fct:hasOverallContactPhone ?overallContactPhone."
               +  "?t fct:hasOverallContactEmail ?overallContactEmail."
			   + "?t fct:hasPhase ?phase."
			   + "?t fct:hasStartDate ?startDate."
			   + "?t fct:hasCompletionDate ?completeDate."
			   + " ?t fct:hasCondition ?cond."
			   + "?t fct:hasStudyType ?studyType."
			   + "?t fct:hasSamplingMethod ?sampMeth."
			   + "?t fct:hasCriteriaText ?criteria."
			   + "?t fct:hasHealthyVolunteers ?volun."
			   + "?t fct:hasGender ?gender."
			   + "?t fct:hasMinAge ?minAge."
			   + "?t fct:hasMaxAge ?maxAge. "
			   + "?t fct:hasIntervention ?inter."
			   + "?inter fct:hasInterventionName ?intername."
			   + "?inter fct:hasInterventionType ?intertype."
			   + "?inter fct:hasInterventionDescr ?interdesc."
			   + " ?inter fct:hasInterventionArmGroupLabel ?armGrpLbl."
               + "?inter fct:hasInterventionOtherName ?oname."
               + "?t fct:hasLocation ?loc."
               + " ?loc fct:hasLocFacility ?fac."
                + "?loc fct:hasLocStatus ?stat."
                 + "?loc fct:hasLocCity ?loccity."
               + " ?loc fct:hasLocCountry ?locCountry."
               + " ?loc fct:hasLocState ?locstate."
                + "?loc fct:hasLocZip ?locZip."
                + "?loc fct:hasInvestigatorName ?invest."
                + " ?loc fct:hasLocContactName ?loccontactname."
                 + "?loc fct:hasLocContactPhone ?locContactphone."
                + " ?loc fct:hasLocContactEmail ?locContactemail."
                + "?loc fct:hasLocBackupContactName ?locBkupName."
                 + "?loc fct:hasLocBackupContactPhone ?locBkupPhone."
                + " ?loc fct:hasLocBackupContactEmail ?locBkupEmail."
			   + "}");   
	   
	   GraphQueryResult results = gQuery.evaluate();   
	   String resultsStr = formatResults(results);   
	   conn.close();    
	   return resultsStr;
	   } 
/**
 * This returns a list of all conditions in the database, in a string with the format
 * [cond1, cond2, ....] which is JSON array format
 * @return JSON array
 */
   public String returnAllDistinctConditions() {
	   String resultStr= "[";
	   ArrayList<String> condList = new ArrayList<String>();
	   conn = repo.getConnection();  
	   TupleQuery selectQuery = conn.prepareTupleQuery("select distinct ?cond where {?nct fct:hasCondition ?cond} order by ?cond");
	   TupleQueryResult result= selectQuery.evaluate();
	   int i=0;
	   while (result.hasNext()) {
		   BindingSet bindingSet = result.next();
		   Value cond = bindingSet.getValue("cond");
	
		   condList.add(cond.stringValue());
		   i++;
		   //resultStr = resultStr + " " + cond.stringValue();
	   }
	   String listStr = String.join(",",condList);
	   resultStr = resultStr + listStr +" ]";
	   return resultStr;
   }
	
private String formatResults(GraphQueryResult results) {
	StringWriter strWriter = new StringWriter();
	String resultsStr="";
	RDFWriter rdfWriter = Rio.createWriter(RDFFormat.JSONLD, strWriter);
	Rio.write(QueryResults.asModel(results), rdfWriter);
	resultsStr = strWriter.toString();
	return resultsStr;
}


}
